;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-intermediate-lambda-reader.ss" "lang")((modname balls-in-box) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #f #t none #f ())))
;; This program starts as an empty canvas of 400 by 300 pixels.
;; By pressing the "n" key on the keyboard,A new ball will be generated on the
;; empty canvas and will be moving in the right direction by default.
;; There will be a counter to display the number of balls generated by the user.
;; The user can select the ball,drag the ball around the canvas.
;; User can select multiple balls if selected in its common area.
;; The ball will bounce around the canvas moving from left to right.
;; The entire world can be paused by pressing the space bar 
;; start with (run x y).
;; where x is the speed of the ball in pixels/tick and 
;;       y is the frame rate
;; eg. (run 10 0.25)

(require rackunit)
(require "extras.rkt")
(require 2htdp/universe)
(require 2htdp/image)

(provide run
         initial-world
         world-after-key-event
         world-after-mouse-event
         world-after-tick
         world-balls
         ball-x-pos
         ball-y-pos
         ball-selected?)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MAIN FUNCTION

;; run : PosInt PosReal -> World
;; GIVEN: A ball speed and a frame rate, in secs/tick.
;; EFFECT: runs the world.
;; RETURNS: the final state of the world.
;; EXAMPLE: (run 8 0.25) creates and runs a world in
;; which each ball travels at 8 pixels per tick and
;; each tick is 0.25 secs.
;; STRATEGY : function composition
(define (run x y)
  (big-bang (initial-world x)
            (on-draw world-to-scene)
            (on-tick world-after-tick y)
            (on-mouse world-after-mouse-event)
            (on-key world-after-key-event)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CONSTANTS
;;
;; dimensions of the canvas
(define CANVAS-WIDTH 400)
(define CANVAS-HEIGHT 300)
(define EMPTY-CANVAS (empty-scene CANVAS-WIDTH CANVAS-HEIGHT))
;;radius of the two circles used
(define RADIUS 20)
(define OUTLINE-BALL (circle RADIUS "outline" "Red"))
(define SOLID-BALL (circle RADIUS "solid" "Red"))
;;
;;; END OF CONSTANTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; DATA DEFINITIONS
;; A Direction is one of 
;; -- "left" interp : Moving in the left direction
;; -- "right" interp : Moving in the right direction
;;
;; template :
;; direction-fn : Direction -> ??
;;(define(direction-fn f)
;;  (cond
;;    [(string=? f "left")...]
;;    [(string=? f "right")...]))

(define-struct ball(x-pos y-pos selected? mouse-x mouse-y direction))
;; A Ball is a (make-ball Real Real Boolean Integer Integer Direction)
;; Interpretation: 
;; x-pos gives the x-coordinate of the ball's center.
;; y-pos gives the y-coordinate of the ball's center.
;; selected? describes whether the ball is selected or not.
;; mouse-x is the x-coordinate of the mouse-pointer.
;; mouse-y is the y-coordinate of the mouse-pointer.
;; direction is the direction in which the ball is travelling.
;;
;; template:
;; ball-fn : Ball -> ??
;; (define (ball-fn b)
;;   (...(ball-x-pos b) (ball-y-pos b) (ball-selected? b)
;; (ball-mouse-x b) (ball-mouse-y b) (ball-direction b)))
;;
;; A ListOfBalls(LOB) is either
;; -- empty   interp : No balls present
;; -- (cons Ball LOB) Interp : List of balls present.
;;
;; template :
;; lob-fn : LOB -> ??
;; (define(lob-fn lob)
;;   (cond
;;     [(empty? lob)...]
;;     [else (...
;;            (ball-fn(first lob))
;;            (lob-fn (rest lob)))]))
;; 
(define-struct world(lob paused? speed))
;; A World is a (make-world LOB Boolean PosInt)
;; Interpretation :
;; lob is the list of balls currently present in the world
;; paused? describes whether the world is paused or not.
;; speed is the speed at which each ball move in each tick in pixels/tick
;;
;; template:
;; world-fn : World -> ??
;; (define (world-fn w)
;;   (...(world-lob w) (world-paused? w) (world-speed w)))
;;
;; 
;; examples of world constant for tests
(define WORLD-FALSE (make-world (list (make-ball 200 150 false 205 155 "right"))
                                false 10))
(define WORLD-TRUE (make-world (list (make-ball 200 150 true 205 155 "right"))
                               true 10))
;;
;;; END OF DATA DEFINITONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; world-after-tick : World -> World
;; GIVEN: A world.
;; RETURNS: The world that should follow w after a tick.
;; Examples : See test cases below.
;; STRATEGY: Structural decomposition on w : World.
(define (world-after-tick w)
  (if (world-paused? w)
      w
      (make-world (ball-after-tick (world-lob w) (world-speed w)) 
                  (world-paused? w) (world-speed w))))

;; balls-after-tick : LOB PosInt -> LOB
;; GIVEN : A list of balls and speed of each ball.
;; RETURNS : A list of balls after tick.
;; Examples : See test cases below.
;; STRATEGY : HOFC
(define (ball-after-tick lob speed)
  (map
   ;; Ball -> Ball
   ;; GIVEN : A ball
   ;; RETURNS : A ball after a single tick.
   (lambda (b)(breaking-the-ball b speed)) 
   lob))

;; breaking-the-ball : Ball PosInt -> Ball
;; GIVEN : A ball and the speed of the ball
;; RETURNS : A ball after one tick in an unpaused world.
;; Examples : See test case below.
;; STRATEGY : Structural decomposition on b : Ball
(define(breaking-the-ball b speed)
  (ball-after-tick-direction (ball-x-pos b) (ball-y-pos b) (ball-selected? b) 
                             (ball-mouse-x b) (ball-mouse-y b) 
                             (ball-direction b) speed))

;; ball-after-tick-direction : Ball PosInt -> Ball
;; GIVEN : A ball and the speed at which it will travel.
;; RETURNS : The same ball after a tick.
;; Examples : See test cases below.
;; STRATEGY : Structural decomposition on dir : Direction
(define (ball-after-tick-direction x y selected? mx my dir speed)
  (cond  
    [(string=? dir "left") 
     (ball-after-tick-left x y selected? mx my dir speed)]
    [(string=? dir "right") 
     (ball-after-tick-right x y selected? mx my dir speed)]))

;; ball-after-tick-left : Integer Integer Boolean String Integer Integer String
;;                        PosInt -> Ball
;; ball-after-tick-right : Integer Integer Boolean String Integer Integer 
;;                         String PosInt-> Ball
;; GIVEN : A position of the ball,mouse coordinates,
;;         whether the ball is selected or not,direction and speed of the ball.
;; RETURNS : The ball that would follow the one in the given position
;;           in a unpaused world.
;; Examples : See test cases below.
;; STRATEGY : function composition.

(define (ball-after-tick-left x-pos y-pos selected? mx my d speed)
  (if selected?
      (make-ball x-pos y-pos selected? mx my d)
      (x-limit-for-ball-going-left x-pos y-pos selected? mx my d speed)))

(define (ball-after-tick-right x-pos y-pos selected? mx my d speed)
  (if selected?
      (make-ball x-pos y-pos selected? mx my d)
      (x-limit-for-ball-going-right x-pos y-pos selected? mx my d speed)))

;; x-limit-for-ball-going-left : Real Real Boolean Integer Integer Direction 
;;                               PosInt -> Ball
;; x-limit-for-ball-going-right : Real Real Boolean Integer Integer Direction 
;;                                PosInt -> Ball
;; GIVEN : A position of the ball,mouse coordinates,
;; whether the ball is selected or not,direction and speed of the ball.
;; RETURNS : The ball that would follow the one in the given position
;; in a unpaused world.
;; Examples : See test case below.
;; STRATEGY : function composition.

(define (x-limit-for-ball-going-left x-pos y-pos selected? mx my d speed)
  (if (<= (- (- x-pos RADIUS) speed) 0)
      (make-ball RADIUS y-pos selected? mx my "right")
      (make-ball (- x-pos speed) y-pos selected? mx my d)))

(define (x-limit-for-ball-going-right x-pos y-pos selected? mx my d speed)
  (if (>= (+ (+ x-pos RADIUS) speed) CANVAS-WIDTH) 
      (make-ball (- CANVAS-WIDTH RADIUS) y-pos selected? mx my "left")
      (make-ball (+ x-pos speed) y-pos selected? mx my d)))

;;Tests
(begin-for-test
  (check-equal? (world-after-tick WORLD-FALSE) 
                (make-world (list (make-ball 210 150 false 205 155 "right")) 
                            false 10) "world unpaused and going to the right")
  (check-equal? (world-after-tick WORLD-TRUE) 
                (make-world (list (make-ball 200 150 true 205 155 "right")) 
                            true 10) "World paused and ball going right")
  (check-equal? (world-after-tick 
                 (make-world (list (make-ball 200 150 false 205 155 "left")) 
                             false 10)) 
                (make-world (list (make-ball 190 150 false 205 155 "left")) 
                            false 10) "World unpaused and ball going left")
  (check-equal? (world-after-tick 
                 (make-world (list (make-ball 200 150 true 205 155 "left")) 
                             true 10)) 
                (make-world (list (make-ball 200 150 true 205 155 "left")) 
                            true 10) "World is paused")
  (check-equal? (world-after-tick 
                 (make-world (list (make-ball 10 100 true 10 100 "left")) 
                             false 20)) 
                (make-world (list (make-ball 10 100 true 10 100 "left")) 
                            false 20) "Ball unselected and going left")
  (check-equal? (world-after-tick 
                 (make-world (list (make-ball 300 100 true 300 100 "right")) 
                             false 20)) 
                (make-world (list (make-ball 300 100 true 300 100 "right")) 
                            false 20) "Ball unselected and going right")
  (check-equal? (world-after-tick 
                 (make-world (list (make-ball 0 100 false 100 100 "left")) 
                             false 30)) 
                (make-world (list (make-ball 20 100 false 100 100 "right")) 
                            false 30)
                "Ball going out of the canvas on the left side")
  (check-equal? (world-after-tick 
                 (make-world (list (make-ball 400 100 false 100 100 "right")) 
                             false 30)) 
                (make-world (list (make-ball 380 100 false 100 100 "left")) 
                            false 30) 
                "Ball going out of the canvas on the right side"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; world-to-scene : World -> Scene
;; GIVEN : A world w
;; RETURNS : A scene that portrays the given world.
;; STRATEGY : structural decomposition on w : World.
;; Examples : See test cases below.
(define (world-to-scene w)
  (place-image (ball-counter (world-lob w)) 
               (- CANVAS-WIDTH 65) (- CANVAS-HEIGHT 12) 
               (world-to-scene-with-balls w)))

;; world-to-scene-with-balls : World -> Scene
;; GIVEN : A world w.
;; RETURNS : An image that portrays the balls in the image.
;; STRATEGY: Structural decomposition on w : World.
;; Examples : See test cases below.
(define (world-to-scene-with-balls w)
  (foldr placing-the-image EMPTY-CANVAS (world-lob w)))

;; placing-the-image : Ball Scene -> Scene
;; GIVEN : A ball and an empty scene.
;; RETURNS : A scene with the ball placed on the initial scene.
;; Examples : See test cases below.
;; STRATEGY : Structural decomposition on ball : Ball.
(define (placing-the-image ball image)
  (place-image (ball-select ball) (ball-x-pos ball) 
               (ball-y-pos ball) image))

;; ball-select : Ball -> Image 
;; GIVEN : A ball.
;; RETURNS : A solid ball iff the ball is selected.
;; and will return a ball with an outline if not selected.
;; STRATEGY : Structural decomposition on b : Ball.
;; Examples : See test cases below.
(define (ball-select b)
  (if (ball-selected? b)
      SOLID-BALL
      OUTLINE-BALL))

;; ball-counter : World -> Image
;; GIVEN : A world.
;; RETURNS : A text image showing the number of balls in the world.
;; STRATEGY : Function composition.
;; Examples : See test cases below.
(define (ball-counter w)
  (text (string-append "Number of Balls : " (number->string (length w)))
        12 "Red"))

;;Tests
(begin-for-test
  (check-equal?
   (world-to-scene (make-world (list (make-ball 200 150 false 205 155 "East"))
                               false 10)) 
   (place-image OUTLINE-BALL 200 150 
                (place-image (text (string-append "Number of Balls : 1")
                                   12 "Red") 
                             (- CANVAS-WIDTH 65) (- CANVAS-HEIGHT 12) 
                             EMPTY-CANVAS)))
  (check-equal?
   (world-to-scene (make-world (list (make-ball 200 150 true 205 155 "East"))
                               false 10)) 
   (place-image SOLID-BALL 200 150 
                (place-image (text (string-append "Number of Balls : 1")
                                   12 "Red") 
                             (- CANVAS-WIDTH 65) (- CANVAS-HEIGHT 12) 
                             EMPTY-CANVAS))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; initial-world : PosInt -> World
;; GIVEN: a ball speed.
;; RETURNS: a world with no balls, but with the
;; property that any balls created in that world
;; will travel at the given speed.
;; Examples : See test cases below.
;; STRATEGY : Function Composition.

(define (initial-world x)
  (make-world (list ) false x))

;;Tests
(begin-for-test
  (check-equal? (initial-world 10) 
                (make-world (list ) false 10) "Initial World"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; world-after-key-event : World KeyEvent -> World
;; GIVEN : A World and a keyevent.
;; RETURNS: The world that should follow the given world after the given
;; key event.
;; STRATEGY : Structural decomposition on kev: KeyEvent.
;; Examples : See test cases below.
(define (world-after-key-event w kev)
  (cond
    [(key=? kev "n") (world-after-n-key w)]
    [(key=? kev " ") (world-with-pause-toggled w)]
    [else w]))

;; world-with-paused-toggled : World -> World
;; RETURNS: a world just like the given one, but with paused? toggled
;; STRATEGY: structural decomposition on w : World

(define (world-with-pause-toggled w)
  (make-world (world-lob w) (not (world-paused? w)) (world-speed w)))

;; world-after-n-key : World -> World
;; GIVEN : A world
;; RETURNS : A world like the given one with the change after pressing
;; the n key.
;; Example: See test cases below.
;; STRATEGY : structural decomposition on 
(define (world-after-n-key w)
  (make-world (cons (make-ball 200 150 false 0 0 "right") (world-lob w)) 
              (world-paused? w) (world-speed w)))
;;Tests
(begin-for-test
  (check-equal? (world-after-key-event 
                 (make-world (list(make-ball 200 150 false 205 155
                                             "right") empty) false 10) "n") 
                (make-world (list (make-ball 200 150 false 0 0 "right") 
                                  (make-ball 200 150 false 205 155 "right")
                                  empty) false 10) 
                "World-after-key event n")
  
  (check-equal? (world-after-key-event 
                 (make-world (list(make-ball 200 150 false 205 155 "East")
                                  empty) false 10) " ") 
                (make-world (list(make-ball 200 150 false 205 155 "East")
                                 empty) true 10) 
                "World-after-key event space")
  
  (check-equal? (world-after-key-event 
                 (make-world (list(make-ball 200 150 false 205 155
                                             "right") empty) false 10) "p") 
                (make-world (list (make-ball 200 150 false 205 155 "right") 
                                  empty) false 10) 
                "World-after-key event other than space and n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; world-after-mouse-event : World Integer Integer MouseEvent -> World
;; GIVEN: A world, the location of a mouse event, and the mouse event itself
;; RETURNS: the world that should follow the given world after the given
;; mouse event at the given location.
;; STRATEGY : Structural decomposition on w : World
;; Examples : See test cases below.
(define (world-after-mouse-event w mx my mev)
  (make-world (making-the-ball-after-key-event (world-lob w) mx my mev) 
              (world-paused? w) (world-speed w)))

;; making-the-ball-after-key-event : LOB Integer Integer MouseEvent -> LOB
;; GIVEN : A list of balls,mouse co-ordinates and a specfic mouse event.
;; RETURNS : A list of balls after application of the mouse event.
;; Examples : See test cases below.
;; STRATEGY : HOFC
(define (making-the-ball-after-key-event lob mx my mev)
  (map
   ;; Ball -> Ball
   ;; GIVEN : A ball
   ;; RETURNS : A ball after the specified mouse event. 
   (lambda(ball)(ball-after-mouse-event ball mx my mev)) 
   lob))

;; ball-after-mouse-event : Ball Integer Integer MouseEvent -> Ball
;; GIVEN : A ball,the location of the mouse pointer and the mouse event
;; RETURNS : A ball after the specific mouse event takes place.
;; STRATEGY : Structural decomposition on mev : MouseEvent
;; Examples : See test cases below.
(define (ball-after-mouse-event ball mx my mev)
  (cond
    [(mouse=? mev "button-down") (ball-after-button-down ball mx my)]
    [(mouse=? mev "drag") (ball-after-drag ball mx my)]
    [(mouse=? mev "button-up") (ball-after-button-up ball mx my)]
    [else ball]))

;; ball-after-button-down : Ball Integer Integer -> Ball
;; GIVEN : A ball and the mouse x,y coordinates.
;; RETURNS : A Ball with selected true if the mouse pointer is inside the ball
;; area else returns the same ball.
;; STRATEGY : Structural decomposition on ball : Ball.
;; Examples : See test cases below.
(define (ball-after-button-down ball mx my)
  (if (in-circle? ball mx my)
      (make-ball (ball-x-pos ball) (ball-y-pos ball) true mx my 
                 (ball-direction ball))
      ball))

;; in-circle? : Ball Integer Integer -> Boolean
;; GIVEN : A ball and the mouse x,y coordinates.
;; RETURNS : true iff the given coordinates are inside the circle.
;; STRATEGY : structural decomposition on ball : Ball.
;; Examples : See test cases below.
(define (in-circle? ball x y)
  (<= (+ (sqr(- (ball-x-pos ball) x)) (sqr (- y (ball-y-pos ball)))) 
      (sqr RADIUS)))

;; ball-after-drag : Ball Integer Integer -> Ball
;; GIVEN : A ball and the mouse x,y coordinates.
;; RETURNS : A ball with the mouse pointer adjusted to remain at the same place
;; even after dragging.
;; STRATEGY : Structural decomposition on ball : Ball.
;; Examples : See test cases below.
(define (ball-after-drag ball mx my)
  (if(ball-selected? ball)
     (make-ball (- mx (- (ball-mouse-x ball) (ball-x-pos ball))) 
                (- my (- (ball-mouse-y ball) (ball-y-pos ball))) true mx my 
                (ball-direction ball)) 
     ball))

;; ball-after-button-up : Ball Integer Integer -> Ball
;; GIVEN : A ball and the mouse x,y coordinates.
;; RETURNS : A ball with selected? turned to false if the ball is selected.
;; STRATEGY : Structural decomposition on ball : Ball.
;; Examples : See test cases below.
(define (ball-after-button-up ball mx my)
  (if (ball-selected? ball)
      (make-ball (ball-x-pos ball) (ball-y-pos ball) false
                 (ball-mouse-x ball) (ball-mouse-y ball) (ball-direction ball))
      ball))

;; world-balls : World -> ListOfBalls
;; GIVEN: A world w.
;; RETURNS: The list of balls that are in the canvas.
;; STRATEGY : Function Composition.
;; Examples : See the test cases below.
(define (world-balls w)
  (world-lob w))

;;Tests
(begin-for-test
  (check-equal? (world-after-mouse-event WORLD-FALSE 205 155 "button-down") 
                (make-world (list(make-ball 200 150 true 205 155 "right"))
                            false 10) 
                "World after button down and ball selected")
  
  (check-equal? (world-after-mouse-event 
                 (make-world (list(make-ball 200 150 false 400 300 "right"))
                             false 10) 400 300 "button-down") 
                (make-world (list(make-ball 200 150 false 400 300 "right"))
                            false 10) 
                "World after button down and ball selected")
  
  (check-equal? (world-after-mouse-event WORLD-TRUE 205 155 "drag") 
                (make-world (list(make-ball 200 150 true 205 155 "right"))
                            true 10)
                "World after drag and ball selected")
  
  (check-equal? (world-after-mouse-event WORLD-FALSE 205 155 "drag") 
                (make-world (list(make-ball 200 150 false 205 155 "right"))
                            false 10) 
                "World after drag and ball unselected")  
  
  (check-equal? (world-after-mouse-event WORLD-TRUE 205 155 "button-up") 
                (make-world (list(make-ball 200 150 false 205 155 "right"))
                            true 10) 
                "World after button up and ball selected")
  
  (check-equal? (world-after-mouse-event WORLD-FALSE 205 155 "button-up") 
                (make-world (list(make-ball 200 150 false 205 155 "right"))
                            false 10)
                "World after button up and ball unselected")
  
  (check-equal? (world-after-mouse-event WORLD-TRUE 205 155 "move") 
                (make-world (list(make-ball 200 150 true 205 155 "right")) 
                            true 10) 
                "World after mouse event and ball returned as it is")
  
  (check-equal? (world-balls WORLD-TRUE)
                (list (make-ball 200 150 true 205 155 "right")) 
                "world-balls List of balls"))


