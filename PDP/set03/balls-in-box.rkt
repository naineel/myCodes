;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-beginner-abbr-reader.ss" "lang")((modname balls-in-box) (read-case-sensitive #t) (teachpacks ((lib "image.rkt" "teachpack" "2htdp"))) (htdp-settings #(#t constructor repeating-decimal #f #t none #f ((lib "image.rkt" "teachpack" "2htdp")))))
;; This program starts as an empty canvas of 400 by 300 pixels.
;; By pressing the "n" key on the keyboard,A new ball will be generated on the
;; empty canvas.There will be a counter to display the number of balls 
;; generated by the user.
;; The user can select the ball,drag the ball around the canvas.
;; User can select multiple balls if selected in its common area.
;; start with (run 0).

(require rackunit)
(require "extras.rkt")
(require 2htdp/universe)
(require 2htdp/image)

(provide
 run
 initial-world
 world-after-key-event
 world-after-mouse-event
 world-balls
 ball-x-pos
 ball-y-pos
 ball-selected?)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MAIN FUNCTION

;; run : Any -> World
;; GIVEN: An argument, which is ignored.
;; EFFECT: runs the world at tick rate of 0.25 secs/tick.
;; RETURNS: the final state of the world.
;; STRATEGY : function composition
(define (run x)
  (big-bang (initial-world x)
            (on-draw world-to-scene)
            (on-tick world-after-tick 0.25)
            (on-mouse world-after-mouse-event)
            (on-key world-after-key-event)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CONSTANTS
;;
;; dimensions of the canvas
(define CANVAS-WIDTH 400)
(define CANVAS-HEIGHT 300)
(define EMPTY-CANVAS (empty-scene CANVAS-WIDTH CANVAS-HEIGHT))
;;radius of the two circles used
(define RADIUS 20)
(define OUTLINE-BALL (circle RADIUS "outline" "Red"))
(define SOLID-BALL (circle RADIUS "solid" "Red"))
;;
;;; END OF CONSTANTS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; DATA DEFINITIONS
;;
(define-struct ball(x-pos y-pos selected? mouse-x mouse-y))
;; A Ball is a (make-ball Integer Integer Boolean Integer Integer)
;; Interpretation: 
;; x-pos gives the x-coordinate of the ball's center.
;; y-pos gives the y-coordinate of the ball's center.
;; selected? describes whether the ball is selected or not.
;; mouse-x is the x-coordinate of the mouse-pointer.
;; mouse-y is the y-coordinate of the mouse-pointer.
;; 
;; template:
;; ball-fn : Ball -> ??
;; (define (ball-fn b)
;;   (...(ball-x-pos b) (ball-y-pos b) (ball-selected? b)
;; (ball-mouse-x b) (ball-mouse-y b)))
;;
;; A ListOfBalls(LOB) is either
;; -- empty
;; -- (cons Ball LOB)
;;
;; template :
;; lob-fn : LOB -> ??
;; (define(lob-fn lob)
;;   (cond
;;     [(empty? lob)...]
;;     [else (...
;;            (ball-fn(first lob))
;;            (lob-fn (rest lob)))]))
;;
;; A World is either 
;; -- empty
;; -- (cons Ball World)
;; 
;; template:
;; world-fn : World -> ??
;; (define (world-fn w)
;;   (cond
;;     [(empty? w) ...]
;;     [else (...
;;             (ball-fn (first w))
;;             (world-fn (rest w)))]))
;;
;;
;; examples of world constant for tests
(define WORLD-FALSE (list(make-ball 200 150 false 205 155)))
(define WORLD-TRUE (list(make-ball 200 150 true 205 155)))
;;
;;; END OF DATA DEFINITONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; world-after-tick : World -> World
;; GIVEN: A world.
;; RETURNS: The world that should follow w after a tick.
;; STRATEGY: Structural decomposition on w : World.
;; Examples : See test cases below.
(define (world-after-tick w)
  (cond
    [(empty? w) empty]
    [else (cons (first w) (world-after-tick (rest w)))]))


(begin-for-test
  (check-equal? (world-after-tick (list empty)) (list empty) " World after
 tick..List should be empty"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; world-to-scene : World -> Scene
;; GIVEN : A world w.
;; RETURNS: A scene that portrays the given world. 
;; STRATEGY: function composition.
;; Examples : See test cases below.
(define (world-to-scene w)
  (place-image (ball-counter w) (- CANVAS-WIDTH 65) (- CANVAS-HEIGHT 12) 
               (world-to-scene-with-balls w)))

;; world-to-scene-with-balls : World -> Scene
;; GIVEN : A world w.
;; RETURNS : An image that portrays the balls in the image.
;; STRATEGY: Structural decomposition on w : World.
;; Examples : See test cases below.
(define (world-to-scene-with-balls w)
  (cond 
    [(empty? w) EMPTY-CANVAS]
    [else (place-image (ball-select (first w)) (ball-x-coordinate(first w)) 
                       (ball-y-coordinate(first w)) 
                       (world-to-scene-with-balls (rest w)))]))

;; ball-x-coordinate : Ball -> Integer
;; GIVEN : A ball
;; RETURNS : x-position of the ball.
(define (ball-x-coordinate ball)
  (ball-x-pos ball))

;; ball-y-coordinate : Ball -> Integer
;; GIVEN : A ball
;; RETURNS : y-position of the ball.
(define (ball-y-coordinate ball)
  (ball-y-pos ball))

(begin-for-test
  (check-equal? (world-to-scene-with-balls
                 (list (make-ball 200 150 false 205 155))) 
                (place-image OUTLINE-BALL 200 150 EMPTY-CANVAS) 
                "world-to-scene-with-balls and list has a ball
 which is unselected")
  
  (check-equal? (world-to-scene-with-balls 
                 (list (make-ball 200 150 true 205 155))) 
                (place-image SOLID-BALL 200 150 EMPTY-CANVAS) 
                "world-to-scene-with-balls and list has a ball 
 which is selected")
  
  (check-equal? (world-to-scene-with-balls (list )) EMPTY-CANVAS 
                "world-to-scene-with-balls and list is empty"))

;; ball-select : Ball -> Image
;; GIVEN : A ball.
;; RETURNS : A solid ball iff the ball is selected.
;; and will return a ball with an outline if not selected.
;; STRATEGY : Structural decomposition on b : Ball.
;; Examples : See test cases below.
(define (ball-select b)
  (if (ball-selected? b)
      SOLID-BALL
      OUTLINE-BALL))

;; ball-counter : World -> Image
;; GIVEN : A world.
;; RETURNS : A text image showing the number of balls in the world.
;; STRATEGY : Function composition.
;; Examples : See test cases below.
(define (ball-counter w)
  (text (string-append "Number of Balls : " (number->string (length w)))
        12 "Red"))

(begin-for-test
  (check-equal? (ball-counter (list(make-ball 200 150 false 205 155))) 
                (text (string-append "Number of Balls : " "1") 12 "Red") 
                "Count of balls on the screen")
  
  (check-equal? (world-to-scene (list (make-ball 200 150 false 205 155)))
                (place-image (text (string-append "Number of Balls : " "1")
                                   12 "Red") 
                             (- CANVAS-WIDTH 65) (- CANVAS-HEIGHT 12) 
                             (place-image OUTLINE-BALL 200 150 EMPTY-CANVAS)) 
                "World-to-scene with ball unselected and showing
 the no of balls on the canvas"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; initial-world : Any -> World
;; GIVEN: An argument, which is ignored.
;; RETURNS: A world with no balls.
;; STRATEGY : Function Composition.
;; Examples : See test cases below.
(define (initial-world x)
  empty)

(begin-for-test
  (check-equal? (initial-world (list(make-ball 200 150 false 205 155) empty))
                empty "initial-world-initialisation"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; world-after-key-event : World KeyEvent -> World
;; GIVEN : A World and a keyevent.
;; RETURNS: The world that should follow the given world after the given
;; key event.
;; STRATEGY : Structural decomposition on kev: KeyEvent.
;; Examples : See test cases below.
(define (world-after-key-event w kev)
  (cond
    [(key=? kev "n") (cons (make-ball 200 150 false 0 0) w)]
    [else w]))

(begin-for-test
  (check-equal? (world-after-key-event (list(make-ball 200 150 false 205 155)
                                            empty) "n") 
                (list (make-ball 200 150 false 0 0) 
                      (make-ball 200 150 false 205 155) empty) 
                "World-after-key event n")
  
  (check-equal? (world-after-key-event (list(make-ball 200 150 false 205 155)
                                            empty) "p") 
                (list (make-ball 200 150 false 205 155) empty) 
                "World-after-key event any other key event"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; world-after-mouse-event : World Integer Integer MouseEvent -> World
;; GIVEN: A world, the location of a mouse event, and the mouse event itself
;; RETURNS: the world that should follow the given world after the given
;; mouse event at the given location.
;; STRATEGY : Structural decomposition on w : World
;; Examples : See test cases below.
(define (world-after-mouse-event w mx my mev)
  (cond
    [(empty? w) empty]
    [else (cons (ball-after-mouse-event (first w) mx my mev)
                (world-after-mouse-event (rest w) mx my mev))]))


;; ball-after-mouse-event : Ball Integer Integer MouseEvent -> Ball
;; GIVEN : A ball,the location of the mouse pointer and the mouse event
;; RETURNS : A ball after the specific mouse event takes place.
;; STRATEGY : Structural decomposition on ball : Ball
;; Examples : See test cases below.
(define (ball-after-mouse-event ball mx my mev)
  (cond
    [(mouse=? mev "button-down") (ball-after-button-down ball mx my)]
    [(mouse=? mev "drag") (ball-after-drag ball mx my)]
    [(mouse=? mev "button-up") (ball-after-button-up ball mx my)]
    [else ball]))


;; ball-after-button-down : Ball Integer Integer -> Ball
;; GIVEN : A ball and the mouse x,y coordinates.
;; RETURNS : A Ball with selected true if the mouse pointer is inside the ball
;; area else returns the same ball.
;; STRATEGY : Structural decomposition on ball : Ball.
;; Examples : See test cases below.
(define (ball-after-button-down ball mx my)
  (if (in-circle? ball mx my)
      (make-ball (ball-x-pos ball) (ball-y-pos ball) true mx my)
      ball))

;; in-circle? : Ball Integer Integer -> Boolean
;; GIVEN : A ball and the mouse x,y coordinates.
;; RETURNS : true iff the given coordinates are inside the circle.
;; STRATEGY : structural decomposition on ball : Ball.
;; Examples : See test cases below.
(define (in-circle? ball x y)
  (<= (+ (sqr(- (ball-x-pos ball) x)) (sqr (- y (ball-y-pos ball)))) 
      (sqr RADIUS)))

;; ball-after-drag : Ball Integer Integer -> Ball
;; GIVEN : A ball and the mouse x,y coordinates.
;; RETURNS : A ball with the mouse pointer adjusted to remain at the same place
;; even after dragging.
;; STRATEGY : Structural decomposition on ball : Ball.
;; Examples : See test cases below.
(define (ball-after-drag ball mx my)
  (if(ball-selected? ball)
     (make-ball (- mx (- (ball-mouse-x ball) (ball-x-pos ball))) 
                (- my (- (ball-mouse-y ball) (ball-y-pos ball))) true mx my) 
     ball))

;; ball-after-button-up : Ball Integer Integer -> Ball
;; GIVEN : A ball and the mouse x,y coordinates.
;; RETURNS : A ball with selected? turned to false if the ball is selected.
;; STRATEGY : Structural decomposition on ball : Ball.
;; Examples : See test cases below.
(define (ball-after-button-up ball mx my)
  (if (ball-selected? ball)
      (make-ball (ball-x-pos ball) (ball-y-pos ball) false
                 (ball-mouse-x ball) (ball-mouse-y ball))
      ball))


;; world-balls : World -> ListOfBalls
;; GIVEN: A world w.
;; RETURNS: The list of balls that are in the canvas.
;; STRATEGY : Function Composition.
;; Examples : See the test cases below.
(define (world-balls w)
  w)

(begin-for-test
  (check-equal? (world-after-mouse-event WORLD-FALSE 205 155 "button-down") 
                (list(make-ball 200 150 true 205 155)) 
                "World after button down and ball selected")
  
  (check-equal? (world-after-mouse-event 
                 (list(make-ball 200 150 false 400 300)) 400 300 "button-down") 
                (list(make-ball 200 150 false 400 300)) 
                "World after button down and ball selected")
  
  (check-equal? (world-after-mouse-event WORLD-TRUE 205 155 "drag") 
                (list(make-ball 200 150 true 205 155)) 
                "World after drag and ball selected")
  
  (check-equal? (world-after-mouse-event WORLD-FALSE 205 155 "drag") 
                (list(make-ball 200 150 false 205 155)) 
                "World after drag and ball unselected")  
  
  (check-equal? (world-after-mouse-event WORLD-TRUE 205 155 "button-up") 
                (list(make-ball 200 150 false 205 155)) 
                "World after button up and ball selected")
  
  (check-equal? (world-after-mouse-event WORLD-FALSE 205 155 "button-up") 
                (list(make-ball 200 150 false 205 155)) 
                "World after button up and ball unselected")
  
  (check-equal? (world-after-mouse-event WORLD-TRUE 205 155 "move") 
                (list(make-ball 200 150 true 205 155)) 
                "World after mouse event and ball returned as it is")
  
  (check-equal? (world-balls WORLD-TRUE)
                WORLD-TRUE))
